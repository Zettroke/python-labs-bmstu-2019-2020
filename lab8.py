##
# Медяновский Олег ИУ7-14Б
# Вычисление определенного интеграла на отрезке от a до b.
# Ввести два шага разбиения, свести результаты методов при данных шагах разбиения в таблицу.
# 1) Симпсона
# 2) Трапеций
# Ввести точность eps,найти необходимое количество разбиений для каждого метода
# для достижения точности eps.

# Первообразная интегрируемой функции
def F(x):
    # return 0.4/5*x**5-5/3*x**3+x**2/2
    return x**3/3


# Интегрируемая функция
def f(x):
    return x**2
    # return 0.4*x**4 - 5*x**2 + x


def trap(st, en, n):
    """
    Метод трапеций
    :param st: Начало интегрируемого промежутка
    :param en: Конец интегрируемого промежутка
    :param n: Количество разбиений промежутка
    :returns: Интеграл промежутка
    """
    step = (en - st) / n
    total = 0
    prev_value = f(st)
    for i in range(n):
        curr = f(st + step * (i + 1))
        s = (prev_value + curr) / 2 * step
        total += s
        prev_value = curr

    return total


def simpson(st, en, n):
    """
    Метод симпсона (парабол)
    :param st: Начало интегрируемого промежутка
    :param en: Конец интегрируемого промежутка
    :param n: Количество разбиений промежутка, должно быть четным
    :returns: Интеграл промежутка
    """
    h = (en - st) / n
    k1 = 0  # нечет
    k2 = 0  # чет
    for i in range(0, n-1, 2):
        k2 += f(st + i*h)
        k1 += f(st + (i+1)*h)
    return h/3*(f(a) + 4*k1 + 2*k2 + f(b))


# Ввод отрезка интегрирования
while True:
    try:
        a, b = map(float, input('Введите начало и конец отрезка: ').split())
        if b <= a:
            print('Конец отрезка должен быть больше начала!')
            continue
        break
    except:
        print('Введите два корректных числа')


# Ввод количества разбиений
while True:
    try:
        n1, n2 = map(int, input('Введите два количества разбиений: ').split())
        if n1 <= 0 or n2 <= 0:
            print('Число разбиений должно быть положительным числом!')
            continue
        break
    except:
        print('Введите два натуральных числа')


v = F(b) - F(a)  # Интеграл по первообразной
print('Интеграл по первообразной: {:.8}'.format(v))

# Сведение результатов методов в таблицу
t1 = trap(a, b, n1)
t2 = trap(a, b, n2)
s1 = simpson(a, b, n1)
s2 = simpson(a, b, n2)
print('┌────────────────────┬────────────────────┬────────────────────┐')
print('│{:^20}│{:^20}│{:^20}│'.format('Метод', 'n1={}'.format(n1), 'n2={}'.format(n2)))
print('├────────────────────┼────────────────────┼────────────────────┤')
print('│{:^20}│{:^20.8}│{:^20.8}│'.format('Трапеций', t1, t2))
print('│{:^20}│{:^20.8}│{:^20.8}│'.format('Симпсона', s1, s2))
print('└────────────────────┴────────────────────┴────────────────────┘')


if n1 > n2:
    t = t1
    s = s1
else:
    t = t2
    s = s2

if abs(v - t) < abs(v - s):
    print('Метод трапеций точнее метода симпсона!')
else:
    print('Метод симпсона точнее метода трапеций!')

while True:
    try:
        eps = float(input('Введите точность eps: '))
        if eps <= 0:
            print('Точность должна быть больше нуля!')
            continue
        break
    except:
        print('Введите корректное число')

# Подбор числа разбиений для метода трапеций
n = 2
t = trap(a, b, n)
while abs(v - t) > eps:
    n *= 2
    t = trap(a, b, n)
print('Метод трапеций дает точность eps={:.5} при {} шагов. Результат: {:.8}'.format(eps, n, t))
# Подбор числа разбиений для метода симпсона
n = 2
s = simpson(a, b, n)
while abs(v - s) > eps:
    n *= 2
    s = simpson(a, b, n)
print('Метод симпмона дает точность eps={:.5} при {} шагов. Результат: {:.8}'.format(eps, n, s))



